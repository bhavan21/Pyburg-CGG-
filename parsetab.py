
# parsetab.py
# This file is automatically generated. Do not edit.
# pylint: disable=W,C,R
_tabversion = '3.10'

_lr_method = 'LALR'

_lr_signature = "ID INT PPERCENT START TERMINALspec : decls PPERCENT rulesspec : declsdecls : emptydecls : decls decldecl : TERMINAL blist '\\n'decl : START lhs '\\n'decl : '\\n'decl : error '\\n'blist : emptyblist : blist ID '=' INToperand : '$' '$'operand : '$' INToperandlist : operandoperandlist : operandlist ',' operandinstruction : ID operandlist ';'instructionlist : emptyinstructionlist : instructionlist instructionreturn_operand : '<' operand '>'return_operand : emptyrules : emptyrules : rules lhs ':' tree '{' instructionlist '}' return_operand '=' INT cost ';' '\\n'rules : rules '\\n'rules : rules error '\\n'lhs : IDtreelist : treelist ',' treetreelist : treetree : IDtree : ID '(' treelist ')'cost : emptycost : '(' INT ')'empty :"
    
_lr_action_items = {'$':([35,41,44,47,],[41,49,41,41,]),'INT':([23,41,51,56,],[26,50,54,59,]),'(':([28,54,],[30,56,]),':':([15,20,],[-24,25,]),')':([28,33,34,39,46,59,],[-27,-26,39,-28,-25,61,]),';':([40,42,49,50,53,54,57,58,61,],[48,-13,-11,-12,-14,-31,60,-29,-30,]),'}':([29,31,32,36,48,],[-31,37,-16,-17,-15,]),'ID':([6,7,9,11,12,13,14,21,24,25,26,29,30,31,32,36,38,48,62,],[-31,-31,15,18,-9,15,-20,-22,-23,28,-10,-31,28,35,-16,-17,28,-15,-21,]),'>':([49,50,52,],[-11,-12,55,]),'error':([0,1,3,4,7,8,10,13,14,17,21,22,24,62,],[-31,5,-3,-7,-31,-4,-8,19,-20,-5,-22,-6,-23,-21,]),',':([28,33,34,39,40,42,46,49,50,53,],[-27,-26,38,-28,47,-13,-25,-11,-12,-14,]),'=':([18,37,43,45,55,],[23,-31,51,-19,-18,]),'{':([27,28,39,],[29,-27,-28,]),'TERMINAL':([0,1,3,4,8,10,17,22,],[-31,6,-3,-7,-4,-8,-5,-6,]),'<':([37,],[44,]),'\n':([0,1,3,4,5,6,7,8,10,11,12,13,14,15,16,17,19,21,22,24,26,60,62,],[-31,4,-3,-7,10,-31,-31,-4,-8,17,-9,21,-20,-24,22,-5,24,-22,-6,-23,-10,62,-21,]),'PPERCENT':([0,1,3,4,8,10,17,22,],[-31,7,-3,-7,-4,-8,-5,-6,]),'$end':([0,1,2,3,4,7,8,10,13,14,17,21,22,24,62,],[-31,-2,0,-3,-7,-31,-4,-8,-1,-20,-5,-22,-6,-23,-21,]),'START':([0,1,3,4,8,10,17,22,],[-31,9,-3,-7,-4,-8,-5,-6,]),}

_lr_action = {}
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = {}
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'tree':([25,30,38,],[27,33,46,]),'decls':([0,],[1,]),'decl':([1,],[8,]),'return_operand':([37,],[43,]),'spec':([0,],[2,]),'cost':([54,],[57,]),'instruction':([31,],[36,]),'operand':([35,44,47,],[42,52,53,]),'rules':([7,],[13,]),'operandlist':([35,],[40,]),'lhs':([9,13,],[16,20,]),'instructionlist':([29,],[31,]),'blist':([6,],[11,]),'treelist':([30,],[34,]),'empty':([0,6,7,29,37,54,],[3,12,14,32,45,58,]),}

_lr_goto = {}
for _k, _v in _lr_goto_items.items():
   for _x, _y in zip(_v[0], _v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = {}
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> spec","S'",1,None,None,None),
  ('spec -> decls PPERCENT rules','spec',3,'p_spec1','gram.py',43),
  ('spec -> decls','spec',1,'p_spec2','gram.py',48),
  ('decls -> empty','decls',1,'p_decls1','gram.py',52),
  ('decls -> decls decl','decls',2,'p_decls2','gram.py',55),
  ('decl -> TERMINAL blist \n','decl',3,'p_decl1','gram.py',58),
  ('decl -> START lhs \n','decl',3,'p_decl2','gram.py',62),
  ('decl -> \n','decl',1,'p_decl3','gram.py',67),
  ('decl -> error \n','decl',2,'p_decl4','gram.py',70),
  ('blist -> empty','blist',1,'p_blist1','gram.py',75),
  ('blist -> blist ID = INT','blist',4,'p_blist2','gram.py',78),
  ('operand -> $ $','operand',2,'p_operand1','gram.py',84),
  ('operand -> $ INT','operand',2,'p_operand2','gram.py',88),
  ('operandlist -> operand','operandlist',1,'p_operandlist1','gram.py',92),
  ('operandlist -> operandlist , operand','operandlist',3,'p_operandlist2','gram.py',96),
  ('instruction -> ID operandlist ;','instruction',3,'p_instruction','gram.py',100),
  ('instructionlist -> empty','instructionlist',1,'p_instructionlist1','gram.py',104),
  ('instructionlist -> instructionlist instruction','instructionlist',2,'p_instructionlist2','gram.py',108),
  ('return_operand -> < operand >','return_operand',3,'p_return_operand1','gram.py',112),
  ('return_operand -> empty','return_operand',1,'p_return_operand2','gram.py',116),
  ('rules -> empty','rules',1,'p_rules1','gram.py',120),
  ('rules -> rules lhs : tree { instructionlist } return_operand = INT cost ; \n','rules',13,'p_rules2','gram.py',124),
  ('rules -> rules \n','rules',2,'p_rules3','gram.py',129),
  ('rules -> rules error \n','rules',3,'p_rules4','gram.py',132),
  ('lhs -> ID','lhs',1,'p_lhs','gram.py',136),
  ('treelist -> treelist , tree','treelist',3,'p_treelist1','gram.py',141),
  ('treelist -> tree','treelist',1,'p_treelist2','gram.py',145),
  ('tree -> ID','tree',1,'p_tree1','gram.py',149),
  ('tree -> ID ( treelist )','tree',4,'p_tree2','gram.py',153),
  ('cost -> empty','cost',1,'p_cost1','gram.py',157),
  ('cost -> ( INT )','cost',3,'p_cost2','gram.py',161),
  ('empty -> <empty>','empty',0,'p_empty','gram.py',169),
]
